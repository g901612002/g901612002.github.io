[{"title":"Angular2 基本使用","date":"2017-03-18T15:50:03.000Z","path":"2017/03/18/Angular2-基本使用/","text":"1. 資料繫結的四種方法 內嵌繫結：{ {property} } 屬性繫結：[property]=&#39;statement&#39; 事件繫結：(event)=&#39;someMethod($event)&#39; 雙向繫結：[(ngModel)]=&#39;property&#39; 123456789&lt;!-- 內嵌繫結 --&gt;&lt;h1&gt;&#123;&#123;employee.name&#125;&#125;&lt;/h1&gt; &lt;!-- 屬性繫結 --&gt;&lt;h1 [innerText]=\"employee.name\"&gt;&lt;/h1&gt; &lt;!-- 雙向繫結 --&gt;&lt;input [(ngModel)]=\"employee.name\"/&gt; &lt;!-- 事件繫結 --&gt;&lt;button (click)=\"save()\"&gt;Save&lt;/h1&gt; 2. 範本參考變數 (#name) 會在範本內建立一個名為 name 的區域變數 該 name 區域變數將只能用於目前元件範本中 該 name 區域變數將會儲存該標籤的 DOM 物件 123&lt;form #heroForm (ngSubmit)=\"onSubmit(heroForm)\"&gt; &lt;input type=\"text\" name=\"username\"&gt;&lt;/form&gt; 3. 三種 Angular 指令 (Directives) 元件型指令 屬性型指令：這種指令會修改元素的外觀或行為 (NgStyle、NgClass) 結構型指令：NgIf、NgFor 或 NgSwitch 12345678910&lt;!-- 元件型指令 --&gt;&lt;hero-detail&gt;&lt;/hero-detail&gt;&lt;!-- 屬性型指令 --&gt;&lt;div [ngClass]=\"&#123;'red':true&#125;\"&gt;測試&lt;/div&gt;&lt;!-- 結構型指令 --&gt;&lt;!-- index 來取得變量，類似 index 的值，例如last、even和odd，請參閱 NgFor API 參考。 --&gt;&lt;li *ngFor=\"let hero of heroes; let i=index;trackBy:hero?.id\"&gt;&lt;/li&gt;&lt;hero-detail *ngIf=\"selectedHero\"&gt;&lt;/hero-detail&gt; 4. 元件的輸入輸出 傳入屬性 @Input() myProperty; 外層元件請記得用「屬性繫結」傳入資料 傳出事件 建立傳出事件：@Output() myEvent = new EventEmitter(); 觸發事件中增加：this.myEvent.emit(data); 外層元件請記得用「事件繫結」來接收傳出的資料 1234567import &#123; Component, EventEmitter, Input, Output &#125; from '@angular/core';export class HeroDetailComponent &#123;@Input() hero: Hero;@Output() deleteRequest = new EventEmitter&lt;Hero&gt;();....&#125; 12&lt;hero-detail [hero]=\"currentHero\" (deleteRequest)=\"deleteHero($event)\"&gt;&lt;/hero-detail&gt; 5. Pipes 內建的 Pipes 元件 uppercase,lowercase date number,decimal,percent,currency json, sliceAngular 2 並沒有 FilterPipe 與 OrderByPipe 喔! 1&lt;p&gt;&#123;&#123;data | json&#125;&#125;&lt;/p&gt; 6. Service幾乎任何東西都可以是一個服務。服務是一個 class，具有專注的、明確的用途。它應該做一件特定的事情，並把它做好。Angular 讓我們能輕易地把應用邏輯拆分到服務，並通過依賴注入(DI)來在組件中使用這些服務。 設定注入 app.module 中：providers: [自定義Service] 注入服務元件到目前元件 constructor(自定義Service名稱: 自定義Service) {} 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';@Injectable()export class HeroService &#123; private heroes: Hero[] = []; constructor(private backend: BackendService,private logger: Logger) &#123; &#125; getHeroes() &#123; this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123; this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`); this.heroes.push(...heroes); // fill cache &#125;); return this.heroes; &#125;&#125;","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"程式","slug":"程式","permalink":"http://yoursite.com/tags/程式/"},{"name":"ng2","slug":"ng2","permalink":"http://yoursite.com/tags/ng2/"}]},{"title":"Angular-cli","date":"2017-03-17T15:37:02.000Z","path":"2017/03/17/Angular-cli/","text":"Angular CLI 是可以快速產生並開發 Angular2 程式時所需要的檔案範本的工具。Angular CLI 包含了 bundle, lint, unit test, end to end test …等功能因此透過 Angular CLI 工具，我們可以大幅節省許多準備檔案的時間 安裝：可到 Angular-cli 觀看詳細的說明 1. 從未安裝過：執行安裝全域環境：npm install -g angular-cli 2. 更新 angular-cli：由於 angular-cli 版本跳很快，所以這個情況很容易遇到 1.先移除全域環境 (以下指令是 beta.28 以上的版本適用)12npm uninstall -g @angular/clinpm cache clean 2.在重新安裝 angular-cli (安裝最新)1npm install -g @angular/cli@latest 3.本地專案上的 angular-cli 移除掉 (先移除 node_modules，再安裝 angular-cli，再安裝其它套件)123rm -rf node_modules distnpm install --save-dev @angular/cli@latestnpm install 專案架構 指令1. 建立元件 Scaffold Usage Component ng g c my-new-component Directive ng g d my-new-directive Pipe ng g p my-new-pipe Service ng g s my-new-service Class ng g cl my-new-class Interface ng g i my-new-interface Enum ng g e my-new-enum Module ng g m my-module 注意：也可指定相對路徑來建立元件 2. 建置與執行 建立新專案 1ng new 專案名稱 建置專案 (預設為dev環境) 1ng build (會將現有應用程式建置後輸出到 dist/ 目錄下) 建置專案的注意事項 建置專案的過程中，預設為 dev 模式 ( 可切換為 prod 模式 ) 建置專案的過程中，如果是 dev 模式 ( ng build ) config/environment.dev.ts 會取代 src/app/environment.ts 檔案 建置專案的過程中，如果是 prod 模式 ( ng build -prod ) config/environment.prod.ts 會取代 src/app/environment.ts 檔案 你也可以自行定義不同的建置模式 ( ng build –env=NAME ) config/environment.NAME.ts 會取代 src/app/environment.ts 檔案 開啟伺服器 ng build ng serve (npm start) ng serve -prod 只要使用 -prod 參數，預設會把所有 js 檔案合併 (Bundling) 指定不同埠號啟動開發伺服器 ng serve –port 4201 –live-reload-port 49153 檢查： 1ng lint angular-cli.json1. $schema定義說明：目前這份設定檔內，可以用的項目有哪些 2. apps這是在描述這份專案下的環境設定：原始碼的存放位置、輸出位置、資源檔、入口檔、預設前綴詞 (app-xxxx)、全域的 css（含第三方套件設定）、全域的 script（含第三方套件設定） 123456789\"scripts\": [ \"../node_modules/jquery/dist/jquery.js\", \"../node_modules/tether/dist/js/tether.js\", \"../node_modules/bootstrap/dist/js/bootstrap.js\"],\"styles\": [ \"../node_modules/bootstrap/dist/css/bootstrap.css\", \"styles.css\"], (1) 假如要輸出不同支 script 檔案勒？123456789101112// input 指的是目標文件的路徑及檔名，output 則是要輸出的路徑及檔名，lazy 則是帶布林值，設定是否延遲載入。(所以在index.html中只會有第一隻跟第三隻，第二隻是lazyload)\"scripts\": [\"global-script.js\",&#123; \"input\": \"lazy-script.js\", \"lazy\": true &#125;,&#123; \"input\": \"pre-rename-script.js\", \"output\": \"renamed-script\" &#125;,],\"styles\": [\"styles.css\",\"more-styles.css\",&#123; \"input\": \"lazy-style.scss\", \"lazy\": true &#125;,&#123; \"input\": \"pre-rename-style.scss\", \"output\": \"renamed-style\" &#125;,], (2) 當要向下相容瀏覽器版本： 請去polyfills 設定(3) defaults： 設定cli要怎麼跑(4) styleExt： 當產生 component，會自動產生 css 或是 scss…(5) component： 可以設定不要產生測試檔案(sepc) 123456\"defaults\": &#123; \"styleExt\": \"scss\", \"component\": &#123; \"spec\": false &#125;&#125; 3. 自 32 版之後的變更： angular-cli.json 變成 .angular-cli.json .angular-cli.json 中 assets 的陣列內容變成可以是 source 以外的內容(資料夾) 。也就是可以不比把東西放在src底下，可以拿node_module內的資料。 angular-cli.json 中的 assets 屬性存放的是一個陣列，這個陣列會列出有哪些檔案或資料夾是 angular-cli 在建置 ( ng build ) 時需要一起複製到專案輸出作為準備佈署的資料夾（ 預設是 dist ）中。預設的 assets 是在建置時，路徑 src/assets 的目錄和檔案，以及 src/favicon.ico 的檔案會進行複製。 environments 底下有分12345678910111213// old \"environments\": &#123; \"source\": \"environments/environment.ts\", \"dev\": \"environments/environment.ts\", \"prod\": \"environments/environment.prod.ts\"&#125;// new\"environmentSource\": \"environments/environment.ts\",\"environments\": &#123; \"dev\": \"environments/environment.ts\", \"prod\": \"environments/environment.prod.ts\"&#125;","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"程式","slug":"程式","permalink":"http://yoursite.com/tags/程式/"},{"name":"ng2","slug":"ng2","permalink":"http://yoursite.com/tags/ng2/"}]},{"title":"TypeScript","date":"2017-03-12T15:23:07.000Z","path":"2017/03/12/TypeScript/","text":"在寫 Angular2 之前，讓我們先來介紹一下 TypeScript，因為在 Angular2 文件中主要是採用 TS 當作開發語言。雖然你也是可以用 Javascript 寫 Angular2 但為了方便維護且資料的參考上，還是建議使用 TypeScript。 介紹為什麼要使用 TypeScript?在程式語言之中，有區分為強型別和弱型別兩種類型。JavaScript 就是弱型別語言(寫法雖然彈性，但是無法在開發時期檢查型別）而 TypeScript 是一個提供強型別語法的 JavaScript 超集合 特色 提升程式碼品質，會更加好維護 須先編譯：透過預編譯器，向下相容舊有的 JavaScript 寫法 可以直接使用ES6的寫法，不需要顧慮 1234567891011121314151617181920// TypeScriptclass Student&#123; name:string; age:number;&#125;var s1=new Student();s1.name=\"Jim\";s1.age=20;document.write(\"name:\"+s1.name+\" age:\"+s1.age); // 轉換 Javascriptvar Student = (function () &#123; function Student() &#123; &#125; return Student;&#125;)();var s1 = new Student();s1.name = \"Jim\";s1.age = 20;document.write(\"name:\" + s1.name + \" age:\" + s1.age); 基本所有的變數都可以在宣告的時候明確指定變數的型別，如果是不符合的型別內容，編譯器就會發出錯誤提示 TypeScript 類型有 boolean、number 、string 、 array 、 enum 、any 、void boolean、number 、string 宣告：var 變數名稱: 類型 = 值 array 宣告： 單一屬性：var 變數名稱: number[]/string[]= 值 任意類型屬性：var 變數名稱: Array = 值 enum(列舉)： 是 TypeScript 中新添加的，JavaScript 中没有 使用 enum 可以為一組數值賦予有意義的名稱。 any： 和 JavaScript 中 var 宣告一样，動態宣告，能給予任何類型。 any 可以配合矩陣来使用 只建議在開發時還不確定型別時使用，為了程式的穩定還是少用。 void(無型別)： 这个類型僅能在函数中使用 可以將函数的返回類型指定為 void，表示此函数不返回任何值。 1234567891011121314151617181920212223var isDone: boolean = false;var isNumber:number=6;var name: string = \"bob\";var list: number[] = [1, 2, 3];var name: string[] = [\"a\",\"b\",\"c\"];var arr:Array = [1,2,3,\"a\",\"b\",\"c\"]; // 任意類型enum Color &#123;Red , Green, Blue&#125;;//Color.Red = 0,Color.Green = 1 ,Color.Blue = 2enum Color2 &#123;Red = 1, Green, Blue&#125;;//Color2.Red = 1,Color2.Green = 2 ,Color2.Blue = 3var notSure: any = 4;notSure = \"maybe a string instead\";notSure = false;var list: any[] = [1, true, \"free\"];list[1] = 100; //更改 list[1]的值function warnUser(): void &#123; alert(\"This is my warning message\");&#125; TypeScript 函式：TypeScript 可以指定傳入參數和回傳值的型別，避免手誤傳入不正確的參數而導致異常。 1234567891011// 定義function 函式(參數:number,參數:number,....):回傳的型別&#123;//code....return data;&#125;// 範例function add(x: number, y: number): number &#123; return x+y;&#125;add(5,6); TypeScript 函式：選擇性參數 ＆ 參數預設值JavaScript 裡，每個參數都是選擇性的，沒傳值的時候，它的值就是 undefined。在 TypeScript 是不行的！要給定些符號才行 選擇性參數：在参数後面，冒號前面加一个問號，表示選擇性參數。 參數預設值：參數後面直接給定一個值；假如這個參數沒傳入任何，會給預設值。注意：選擇性參數 ＆ 參數預設值 都要放在參數列表最後 12345678910111213141516// 選擇性參數function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName;&#125;var result1 = buildName(\"Bob\"); //Bobvar result2 = buildName(\"Bob\", \"Adams\"); //Bob Adams// 參數預設值function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName;&#125;var result1 = buildName(\"Bob\"); //Bob Smithvar result2 = buildName(\"Bob\", \"Adams\"); //Bob Adams class寫法同 ES6，會有屬性、建構式的特性 屬性 預設都是 public。 private：不要被外部存取。 static：使用時，不需要實體化就能夠呼叫。 繼承有 class 的概念，當然就會有繼承的概念 12345678910111213141516class Student extends Human&#123; // Student 繼承 Human name: string = 'rainbow'; // 屬性預設都是 public，給預設值為 rainbow private birth: Date; // 不要被外部存取 static type: string; // 不需要實體化就能夠呼叫 constructor(name: string)&#123; // 建構式 this.name = name; &#125; getPhoneNumber(): string &#123; //code... &#125;&#125;var student = new Student('john');console.log(student.name); // 可取到Student.type; // 可直接拿到 interface讓參數物件有更明確的結構型態，而不是只是丟個參數表示為一個物件。 12345678interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125; 當 class 實做時使用： implements 1234567891011121314151617interface People &#123; sex: string; allName: string; getAllName(f,l);&#125;class Woman implements People &#123; allName: string; constructor(public firstName: string,public lastName: string) &#123; &#125; getAllName(firstName,lastName) &#123; this.allName = firstName + \" \" + lastName; &#125;&#125;var woman: Woman = new Woman('rainbow','wu');woman.getAllName(); 介面擴充就像 class 一樣，interface 也可以擴充。更利於介面的重用性，讓程式更有彈性。 1234567891011interface Shape &#123; color:string;&#125;interface Square extends Shape &#123; sideLength:number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = 'blue';square.sideLength = 10; Generic (泛型)當你在建構 Function、Interface 及 Class 時，你會希望這些能夠被重複運用，這時候就是要使用 Generic。語法是：&lt;T&gt; &lt;T&gt;不指定具體型別，而是用一個&lt;T&gt;做代替，因為在未來這個&lt;T&gt;會由一個具體的型別所代替。 1234567891011function LogAndReturn&lt;T&gt;(thing:T):T &#123; console.log(thing); return thing;&#125;let stringLog:string = LogAndReturn&lt;string&gt;('string log');let numberLog:number = LogAndReturn&lt;number&gt;(1000);let newBook:Book = &#123;title:'This is a Book'&#125;;let bookLog:Book = LogAndReturn&lt;Book&gt;(newBook);","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"程式","slug":"程式","permalink":"http://yoursite.com/tags/程式/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"Angular2-基本介紹","date":"2017-03-11T18:28:50.000Z","path":"2017/03/12/Angular2-基本介紹/","text":"筆者因為公司的專案開始學習ng2，想說來做一下記錄好了。之前公司是寫ng1，因此對ng2也是相當感興趣…. 不過，坦白說ng2相對起來，門檻比起台灣火紅的其他框架高許多但個人覺得他是野心太大，把火紅的新技術都放入當中所以我覺得是未來趨勢啦(因此還是含淚給它吞下去QWQ) 1.介紹Angular 2它是 Google 開發出來一款開源 JavaScript 框架，用來協助單一頁面應用程式運行的。它的目標是透過 MVC 模式（MVC）功能增強瀏覽器的應用，使開發和測試變得更加容易。 編寫程式Angular 選擇了 TypeScript 作為主語言。因為 TypeScript 是超集合的 JavaScript，包含了ES6、ES7…目的是改用一些結構良好或是更輕鬆的語言來開發應用程式。如果你是個 C# 工程師，一定會對它的語法感覺相當親切～ 團隊合作Angular 對團隊作戰提供了良好的支持，比如模板與程式碼的分離、樣式表的局部化、組件化的設計、服務與依賴注入體係等。 2.主要特色與功能 跨平台 ProgressiveWebApps DesktopApps (Electron 框架) NativeApps (Ionic Native, NativeScript, React Native) 速度與效能 Codegeneration(AOT) 將元件範本預先編譯成 JS 程式碼 Universal 將開啟頁面的首頁預先產生完整 HTML 與 CSS 原始碼，加快首頁載入速度 可支援 Node.js, .NET, PHP 或任何其他伺服器端網頁架構 CodeSplitting 透過全新的元件路由機制，讓使用者只須載入需要的原始碼 3.架構 ng2 都是由元件組成的。 範本(Template) 類別(Class) 中繼資料(Metadata) HTML版面配置 建構式(Constructor) 裝飾器(Decorator) HTML部分片段 屬性 資料繫結 方法 畫面指令(Directives)","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"程式","slug":"程式","permalink":"http://yoursite.com/tags/程式/"},{"name":"ng2","slug":"ng2","permalink":"http://yoursite.com/tags/ng2/"}]},{"title":"前端好碰友：Jsonbin","date":"2017-03-06T14:37:08.000Z","path":"2017/03/06/前端好碰友：Jsonbin/","text":"身為前端人，有許多坑可以從東玩到西，當我們要試試新的framework 或是 新的技術時最基本的練功方式就是做一個小小的玩意兒有一項就是不可避免的，那就是呼叫API 進行串接 以前我們可能會用 json generator 來產生假的json但那只是模擬而已。 現在有很好的工具，可以模擬我們串接api時的情況而且相當的好用！ 現在我們就來說說唄～ 1. 進入此網站：使用自己的github帳號進行登入 ：https://jsonbin.org/ 登入後，會出現這些資訊： 2. 使用Postman來操作API： 發出api請求有兩種開頭： /me /github 名稱 12345// 方法一https://jsonbin.org/me/(要取的api名稱)// 方法二https://jsonbin.org/(github名稱)/(要取的api名稱) 發 api時，header 要帶的token（apikey）： {authorization: token ==apikey==} 操作動作： get (取單筆：api/id) post put delete 3. 對某支 api 公開/改為非公開(步驟)： 改為公開： api…/_perms 動作：put (return true 就是修改成功) 改為非公開： api…/_perms 動作：delete (return true 就是修改成功) 4. 參考影片：","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"部落格：github pages + HEXO","date":"2017-03-04T17:26:27.000Z","path":"2017/03/05/github-pages-and-hexo/","text":"恩….最近終於下定決心要來做部落格紀錄一些工作上的事，所以想說來使用最簡單的 github pages + HEXO建立完成就順便記錄一下當一篇好了 XDDD以下就是製作說明： 1. Github Pages在你的 github 申請一個新的專案，申請的專案名稱： yourgithubname.github.io 2. Hexo 安裝( 安裝 Hexo 之前，請先安裝 node ＸＤＤＤ) 123hexo init yourgithubnamecd yourgithubnamenpm install 設定 _config.yml (設定內容主要有以下幾點：) 修改網站名稱 作者 主題設定 連結 github Pages （這一定要修改） 12345// 注意：yml 格式要求嚴格，:後面只能一個空白鍵，deploy 下方的設定都要縮行！不然會報錯！deploy: type: git repo: https://github.com/yourgithubname/yourgithubname.github.io.git branch: master 常用指令 1234567// 發佈前設計hexo s #在本機預覽網站// 發布動作：hexo clean #清除內容（如果擔心之前的修改不徹底或是有殘留的檔案，可以先 clean 再 g）hexo g #生成內容（發文等更新需要用）hexo d #發佈網站 主題你可以用 $ git clone 的方式安裝，也可以下載 .zip，把它解壓縮到 /themes/ 資料夾裡，接著編輯 _config.ymlHexo : https://hexo.io/themes 3. 文章 編寫文章 Hexo 的文章原始檔都以 .md 格式存在 ~/source/_post/ 資料夾裡面 $ hexo new “標題” 指令新建空白檔案。 設定內容一篇 Hexo 文章的開頭應該包括標題（Title）、分類（Category）、標籤（Tag）、發佈時間（Date）等等。 123456789101112--- title: ＃／McK &amp; Note 架站筆記：基礎篇date: 2016-4-4 14:30:00tags: - Hexo- GitHub- Markdown- NexTcategories: ＃comments: true---（下續內文） 特別注意 tags 是平行關係， categories 則有上下層關係。 4. 常見 Markdown 格式12345678910斜體： *斜體* 粗體： **粗體** 粗斜體： ***粗斜體*** 刪除線：~~刪除~~ 引言： &gt; 引言 章節： # 章節次級章節（以此類推）： ## 次級章節表格（註1）：|一行|一行|疊|插入超連結： [超連結文字](網址) 插入外部圖片： ![圖片描述](圖片網址) 參考：http://github.hopotwing.top/writing-hexo-blog-in-markdown/ 5. 當產生分類頁或產生標籤頁 123456789// ~/themes/next/_config.ymlmenu: home: / categories: /categories #about: /about # About 頁面沒啟用 archives: /archives tags: /tags #commonweal: /404.html # 公益 404 頁面不會顯示在目錄 並在 ~/source/ 底下建立相應的 /tags/ 或 /catagories/ 資料夾，並在裡面新增一個 index.md，以 tags 為例內容如下： 12345678// ~/source/tags/index.md---title: 標籤date: 2016-03-15type: \"tags\"comments: false #關閉評論功能---","comments":true,"categories":[],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://yoursite.com/tags/筆記/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]}]